package com.design.patterns.demo.designpattern.structure.flyweight.game.v2;

import java.util.HashMap;
import java.util.Map;

import com.design.patterns.demo.designpattern.structure.flyweight.game.Color;

/**
 * ChessBoard 棋局类
 *
 * 我们利用工厂类来缓存 ChessPieceUnit 信息（也就是 id、text、color）。
 * 通过工厂类获取到的 ChessPieceUnit 就是享元。所有的 ChessBoard 对象共
 * 享这 30 个 ChessPieceUnit 对象（因为象棋中只有 30 个棋子）。在使用享
 * 元模式之前，记录 1 万个棋局，我们要创建 30 万（30*1 万）个棋子的
 * ChessPieceUnit 对象。利用享元模式，我们只需要创建 30 个享元对象供所有棋局
 * 共享使用即可，大大节省了内存。
 *
 *
 * 享元模式的原理所谓“享元”，
 *
 * 顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。
 *
 * 具体来讲，当一个系统中存在大量重复对象的时候，我们就可以利用享元模式，将对象设计成享元，在
 * 内存中只保留一份实例，供多处代码引用，这样可以减少内存中对象的数量，以起到节省内存的目的。
 *
 * 实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段），
 * 提取出来设计成享元，让这些大量相似对象引用这些享元。
 *
 * 2. 享元模式的实现享元模式的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map
 * 或者 List 来缓存已经创建好的享元对象，以达到复用的目的。
 *
 * 3. 享元模式 VS 单例、缓存、对象池
 *
 * 区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。
 *
 * 享元模式跟单例的区别?
 *
 * 在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，
 * 每个对象被多处代码引用共享。实际上，享元模式有点类似于之前讲到的单例的变体：多例。
 *
 * 我们前面也多次提到，区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。
 *
 * 尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上来看，它们是完全不同的。
 * 应用享元模式是为了对象复用，节省内存，而应用多例模式是为了限制对象的个数。
 *
 * 享元模式跟缓存的区别?
 *
 * 在享元模式的实现中，我们通过工厂类来“缓存”已经创建好的对象。这里的“缓存”实际上是“存储”的意思，
 * 跟我们平时所说的“数据库缓存”“CPU 缓存”“MemCache 缓存”是两回事。我们平时所讲的缓存，主要是为了提高访问效率，而非复用。
 *
 *
 * 享元模式跟对象池的区别?
 *
 * 虽然对象池、连接池、线程池、享元模式都是为了复用，但是，如果我们再细致地抠一抠“复用”这个字眼的话，
 * 对象池、连接池、线程池等池化技术中的“复用”和享元模式中的“复用”实际上是不同的概念。池化技术中的
 * “复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库池中取一个连接，不需要重新创建）。在任意
 * 时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由
 * 其他使用者重复利用。
 *
 * 享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享的，主要目的是节省空间。
 *
 *
 * 定义中的“不可变对象”指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）
 * 就不会再被修改了。所以，不可变对象不能暴露任何 set() 等修改内部状态的方法。之所以要求享元是
 * 不可变对象，那是因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。
 *
 * @author wangjixue
 * @date 8/8/22 10:50 PM
 */
public class ChessBoard {
    private Map<Integer, ChessPiece> chessPieceMap = new HashMap<>();

    public ChessBoard() {
        init();
    }

    private void init(){
        chessPieceMap.put(1,new ChessPiece(ChessPieceUnitFactory.getChessPieceUnit(1),0,0));
        chessPieceMap.put(2,new ChessPiece(ChessPieceUnitFactory.getChessPieceUnit(2),0,1));
        // 其他棋子
    }

    public void move(int chessPieceId, int toPositionX, int toPositionY){
        //TODO 待实现
    }
}
